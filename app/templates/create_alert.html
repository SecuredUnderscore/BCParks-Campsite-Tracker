{% extends "base.html" %}

{% block content %}
<div class="card" style="max-width: 1000px;">
    <h2>{% if alert %}Edit Alert{% else %}Create New Alert{% endif %}</h2>
    <style>
        .campsite-marker {
            width: 14px;
            height: 14px;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: black;
            border-radius: 50%;
            cursor: pointer;
            position: absolute;
            transform: translate(-5%, 15%);
            /* User tuning: -5% X, +15% Y */
            /* Center the dot on the point */
        }

        @media (max-width: 768px) {
            .campsite-marker {
                width: 12px;
                height: 12px;
                /* font-size: 0px !important; REVERTED: User wants numbers visible */
                font-size: 7px;
                /* Slightly smaller text for mobile */
                border-width: 1px !important;
            }
        }
    </style>
    <form id="alertForm" method="POST">
        <input type="hidden" name="action" value="create_alert">
        <input type="hidden" id="selectedCampsiteIds" name="campsite_ids">
        <input type="hidden" id="subCampgroundName" name="sub_campground_name"
            value="{{ alert.sub_campground_name if alert else '' }}">

        <!-- Step 1: Campground -->
        <div class="form-group">
            <label>1. Select Campground</label>
            <select id="campgroundSelect" name="campground_id" style="width: 100%; padding: 12px; font-size: 16px;">
                <option value="">Loading campgrounds...</option>
            </select>
        </div>

        <!-- Step 2: Sub-Campground (Hidden by default) -->
        <div class="form-group" id="subCampgroundContainer" style="display: none; margin-top: 15px;">
            <label>2. Select Sub-Campground</label>
            <select id="subCampgroundSelect" name="sub_campground_id"
                style="width: 100%; padding: 12px; font-size: 16px;">
                <option value="">Select...</option>
            </select>
        </div>

        <!-- Step 3: Map & Campsites -->
        <div id="mapSection" style="display: none; margin-top: 20px;">
            <label>3. Select Campsites (Click on map points or use 'Select All')</label>
            <div style="margin-bottom: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button type="button" id="selectAllBtn">Select All</button>
                <button type="button" id="selectNoneBtn">Select None</button>
                <span id="selectionCount" style="margin-left: 10px; align-self: center;">0 selected</span>
            </div>

            <div id="mapContainer"
                style="position: relative; overflow: hidden; border: 1px solid #ccc; min-height: 300px; background: #eee;">
                Loading Map...
            </div>
        </div>

        <!-- Step 4: Dates & Criteria -->
        <div style="margin-top: 20px; border-top: 1px solid #eee; padding-top: 15px;">
            <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                <div style="flex: 1; min-width: 200px;">
                    <label>Start Date</label>
                    <input type="date" name="start_date" required value="{{ alert.start_date if alert else '' }}"
                        style="padding: 10px;">
                </div>
                <div style="flex: 1; min-width: 200px;">
                    <label>End Date</label>
                    <input type="date" name="end_date" required value="{{ alert.end_date if alert else '' }}"
                        style="padding: 10px;">
                </div>
                <div style="flex: 1; min-width: 150px;">
                    <label>Min Nights</label>
                    <input type="number" name="min_nights" value="{{ alert.min_nights if alert else 1 }}" min="1"
                        required style="padding: 10px;">
                </div>
            </div>
        </div>

        <div style="margin-top: 20px;">
            <button type="submit" style="font-size: 1.2em; padding: 10px 20px;">{% if alert %}Save Changes{% else
                %}Create Alert{% endif %}</button>
            <a href="{{ url_for('main.index') }}" style="margin-left: 10px;">Cancel</a>
        </div>
    </form>
</div>



<script>
    document.addEventListener('DOMContentLoaded', async () => {
        const campgroundSelect = document.getElementById('campgroundSelect');
        const subContainer = document.getElementById('subCampgroundContainer');
        const subSelect = document.getElementById('subCampgroundSelect');
        const mapSection = document.getElementById('mapSection');
        const mapContainer = document.getElementById('mapContainer');
        const selectionCount = document.getElementById('selectionCount');
        const hiddenInput = document.getElementById('selectedCampsiteIds');

        // Pre-population Data
        const initialCampId = "{{ alert.campground_id if alert else '' }}";
        const initialSubId = "{{ alert.sub_campground_id if alert else '' }}"; // This is mapId in backend logic? No, map array index? 
        // Wait, sub_campground_id in MODEL is an integer (likely mapIndex? or mapId?).
        // In my current logic (Step 195/226 in older files), I save `sub_id`.
        // BUT `subSelect` values are the ARRAY INDEX of the map in `currentParkData.maps`.
        // The `sub_campground_id` stored in DB... let's check what I saved.
        // In `create_alert` route: `request.form.get('sub_campground_id')`.
        // The `option` value is `originalIndex` (Step 153).
        // So `sub_campground_id` stored in DB is the INDEX.
        // That matches what I need to select.

        // However, if the park data changes (maps reordered), index might be fragile. 
        // But for now, assuming index is persistent enough or API consistent.

        const initialSites = {{ alert.campsite_ids | tojson if alert else '[]'
    }};

    let selectedIds = new Set(initialSites);
    let currentParkData = null; // { maps: [], resources: {} }

    // Update hidden input initially if editing
    if (selectedIds.size > 0) updateCount();

    // 1. Fetch Campgrounds
    try {
        const res = await fetch('/api/proxy/campgrounds');
        const data = await res.json();
        campgroundSelect.innerHTML = '<option value="">Select a Campground...</option>';
        data.forEach(cg => {
            let name = 'Unknown';
            if (cg.localizedValues && cg.localizedValues[0] && cg.localizedValues[0].shortName) {
                name = cg.localizedValues[0].shortName;
            } else if (cg.shortName) {
                name = cg.shortName;
            } else if (cg.localizedValues && cg.localizedValues[0]) {
                name = cg.localizedValues[0].fullName;
            }

            const opt = document.createElement('option');
            opt.value = cg.resourceLocationId;
            opt.innerText = name;
            if (initialCampId && String(cg.resourceLocationId) === String(initialCampId)) {
                opt.selected = true;
            }
            campgroundSelect.appendChild(opt);
        });

        // Trigger load if selected
        if (campgroundSelect.value) {
            await loadParkData(campgroundSelect.value);
        }

    } catch (e) {
        campgroundSelect.innerHTML = '<option>Error loading campgrounds</option>';
        console.error(e);
    }

    // Handle Campground Selection
    campgroundSelect.addEventListener('change', async () => {
        await loadParkData(campgroundSelect.value);
    });

    async function loadParkData(resourceLocationId) {
        mapSection.style.display = 'none';
        subContainer.style.display = 'none';
        subSelect.innerHTML = '';
        currentParkData = null;

        if (!resourceLocationId) return;

        mapContainer.innerHTML = 'Loading Park Data...';
        mapSection.style.display = 'block';

        try {
            const res = await fetch(`/api/proxy/park_data/${resourceLocationId}`);
            if (!res.ok) throw new Error(`Fetch failed ${res.status}`);
            const data = await res.json();

            if (data.error) {
                mapContainer.innerHTML = 'Error: ' + data.error;
                return;
            }

            currentParkData = data;

            // Populate Sub-Maps
            let displayMaps = [];
            if (currentParkData.maps) {
                displayMaps = currentParkData.maps.filter(m => m.mapResources && m.mapResources.length > 0);
                if (displayMaps.length === 0 && currentParkData.maps.length > 0) {
                    displayMaps = currentParkData.maps;
                }
            }

            if (displayMaps.length > 0) {
                subContainer.style.display = displayMaps.length > 1 ? 'block' : 'none';
                subSelect.innerHTML = '';

                let indexToSelect = -1;

                displayMaps.forEach((m) => {
                    const originalIndex = currentParkData.maps.indexOf(m);
                    const opt = document.createElement('option');

                    // Use mapId as the value (IMPORTANT for worker)
                    opt.value = m.mapId;
                    // Store index for rendering logic
                    opt.dataset.index = originalIndex;

                    let title = `Map ${m.mapId}`;
                    if (m.localizedValues && m.localizedValues[0]) {
                        title = m.localizedValues[0].title;
                    }
                    opt.innerText = title;
                    opt.dataset.name = title;

                    if (initialSubId && String(m.mapId) === String(initialSubId)) {
                        opt.selected = true;
                        indexToSelect = originalIndex;
                    }

                    subSelect.appendChild(opt);
                });

                // If no initial selection, or initial not found, select first
                if (indexToSelect === -1) {
                    indexToSelect = parseInt(subSelect.options[0].dataset.index);
                    subSelect.value = subSelect.options[0].value;
                    // Set hidden name
                    document.getElementById('subCampgroundName').value = subSelect.options[0].dataset.name;
                } else {
                    // Ensure hidden name is updated for the selected initial
                    const selectedOpt = Array.from(subSelect.options).find(o => o.dataset.index == indexToSelect);
                    if (selectedOpt) document.getElementById('subCampgroundName').value = selectedOpt.dataset.name;
                }

                renderMap(indexToSelect);
            } else {
                mapContainer.innerHTML = 'No interactive maps found for this location.';
            }

        } catch (e) {
            console.error(e);
            mapContainer.innerHTML = 'Error loading park data.';
        }
    }

    // Handle Sub-Map Selection
    subSelect.addEventListener('change', () => {
        // Clear previous selection to avoid cross-map pollution (Bug Fix)
        if (selectedIds.size > 0) {
            if (confirm("Switching maps will clear your current site selection. Continue?")) {
                selectedIds.clear();
                updateCount();
            } else {
                // Revert selection? Hard to revert dropdown easily without tracking previous index.
                // For now, let's just clear it or warn.
                // Simpler: Just clear it. It's confusing to mix.
            }
        }
        selectedIds.clear();
        updateCount();

        // Value is now mapId, but renderMap needs index
        const index = parseInt(subSelect.options[subSelect.selectedIndex].dataset.index);
        if (subSelect.selectedIndex >= 0) {
            document.getElementById('subCampgroundName').value = subSelect.options[subSelect.selectedIndex].dataset.name;
        }
        renderMap(index);
    });

    function renderMap(mapIndex) {
        if (!currentParkData || !currentParkData.maps[mapIndex]) return;

        const mapData = currentParkData.maps[mapIndex];
        const resources = currentParkData.resources || {};

        mapContainer.innerHTML = '';
        // Don't clear selectedIds here if we want to persist them across map switches? 
        // In creation flow, I cleared them. But when editing, I want to show existing.
        // When switching maps, usually you lose selection in this app design?
        // "Select Campsites (Click on map points...)" implies strict binding to map.
        // If I switch maps, the resources on that map are different.
        // However, `selectedIds` contains ALL ids for the ALERT.
        // If the alert spans multiple maps (unlikely in this UI), we should keep them.
        // BUT, the initial load should populate `selectedIds` from `initialSites`.
        // I set `selectedIds = new Set(initialSites)` at the top.
        // So I should NOT clear them here.
        // selectedIds.clear(); 
        updateCount();

        // Ensure image
        const imgUrl = mapData.mapImageUrls ? mapData.mapImageUrls['en-CA'] : null;
        if (!imgUrl) {
            mapContainer.innerHTML = 'Map image not available.';
            return;
        }

        const img = new Image();
        img.onload = () => {
            const startX = mapData.xDimension || 800;
            const startY = mapData.yDimension || 600;

            const wrapper = document.createElement('div');
            wrapper.style.position = 'relative';
            wrapper.innerHTML = '';
            wrapper.appendChild(img);

            if (mapData.mapResources) {
                mapData.mapResources.forEach(pt => {
                    const resId = pt.resourceId;

                    let resName = resId;
                    if (resources[resId] && resources[resId].localizedValues) {
                        resName = resources[resId].localizedValues[0].name;
                    }

                    const dot = document.createElement('div');
                    dot.className = 'campsite-marker';
                    dot.style.left = (pt.xCoordinate / startX * 100) + '%';
                    dot.style.top = (pt.yCoordinate / startY * 100) + '%';

                    const isSelected = selectedIds.has(resId);
                    dot.style.background = isSelected ? '#ADD8E6' : 'rgba(128, 128, 128, 0.9)';
                    dot.style.border = '1px solid ' + (isSelected ? '#0000FF' : '#555');

                    dot.innerText = resName;
                    dot.title = `Site: ${resName}`;
                    dot.setAttribute('data-res-id', resId);
                    dot.onclick = () => toggleSelection(resId, dot);
                    wrapper.appendChild(dot);
                });
            }
            mapContainer.appendChild(wrapper);
        };

        img.src = imgUrl;
        img.style.width = '100%';
        img.style.display = 'block';
    }

    function toggleSelection(id, el) {
        if (selectedIds.has(id)) {
            selectedIds.delete(id);
            el.style.background = 'rgba(128, 128, 128, 0.9)';
            el.style.border = '1px solid #555';
        } else {
            selectedIds.add(id);
            el.style.background = '#ADD8E6';
            el.style.border = '1px solid #0000FF';
        }
        updateCount();
    }

    function updateCount() {
        selectionCount.innerText = `${selectedIds.size} selected`;
        hiddenInput.value = JSON.stringify(Array.from(selectedIds));
    }

    document.getElementById('selectAllBtn').addEventListener('click', () => {
        const dots = mapContainer.querySelectorAll('div[data-res-id]');
        dots.forEach(dot => {
            const id = parseInt(dot.getAttribute('data-res-id'));
            selectedIds.add(id);
            dot.style.background = '#ADD8E6';
            dot.style.border = '1px solid #0000FF';
        });
        updateCount();
    });

    document.getElementById('selectNoneBtn').addEventListener('click', () => {
        // In edit mode, clearing selection clears current map's dots.
        // If we really want to clear ALL including invisible ones, we should just selectedIds.clear().
        // But UI says "Select None" (usually implies visible?)
        // I'll stick to visual behavior.
        const dots = mapContainer.querySelectorAll('div[data-res-id]');
        dots.forEach(dot => {
            const id = parseInt(dot.getAttribute('data-res-id'));
            selectedIds.delete(id);
            dot.style.background = 'rgba(128, 128, 128, 0.9)';
            dot.style.border = '1px solid #555';
        });
        updateCount();
    });
    });
</script>


{% endblock %}